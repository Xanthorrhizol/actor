{"config":{"lang":["en","ko"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"xan-actor Wiki","text":"<p><code>xan-actor</code> is an Akka-style Actor model library implemented in Rust.</p> <p>This wiki focuses on:</p> <ul> <li>running multiple Actor types in a single <code>ActorSystem</code></li> <li>compile-time message type checking via <code>send::&lt;T&gt;()</code></li> <li>address-based routing and lifecycle control</li> <li>bounded/unbounded channel modes</li> </ul>"},{"location":"#documentation-map","title":"Documentation Map","text":"<ul> <li><code>Core Concepts</code>: core concepts and type-safety model</li> <li><code>Architecture</code>: internal components and message flow</li> <li><code>Quickstart</code>: minimal example for register/send/recv</li> </ul>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#components","title":"Components","text":"<ul> <li><code>Actor</code> implementations: user business logic</li> <li><code>TypedMailbox&lt;A&gt;</code>: mailbox bound to actor type <code>A</code></li> <li><code>ActorSystem</code>: routing, lifecycle, cache, and job control</li> <li><code>actor_system_loop</code>: command-processing loop</li> </ul>"},{"location":"architecture/#message-flow","title":"Message Flow","text":"<pre><code>Caller\n  -&gt; ActorSystem::send::&lt;T&gt;(address, msg: T::Message)\n  -&gt; ActorSystemCmd::FindActor { actor_type, address }\n  -&gt; Mailbox.send(payload)\n  -&gt; TypedMailbox&lt;A&gt; downcast to A::Message\n  -&gt; Actor::handle(...)\n</code></pre> <p>Key points:</p> <ul> <li>API requires <code>T::Message</code>, so wrong message types fail at compile time</li> <li>internals use <code>Any</code>, but <code>TypedMailbox&lt;A&gt;</code> validates via downcast</li> </ul>"},{"location":"architecture/#address-and-routing","title":"Address and Routing","text":"<p>Addresses are strings filtered by regex (<code>*</code> wildcard conversion).</p> <ul> <li><code>send_broadcast::&lt;T&gt;(regex, msg)</code> sends to every matched address</li> <li>cache (<code>cache</code>) optimizes repeated sends</li> <li>cache entry is dropped when type mismatch or send failure occurs</li> </ul>"},{"location":"architecture/#job-execution-model","title":"Job Execution Model","text":"<p><code>run_job::&lt;T&gt;()</code> executes periodic/iterative messages from <code>JobSpec</code>.</p> <ul> <li><code>subscribe = true</code>: returns <code>result_subscriber_rx</code></li> <li>control APIs: <code>stop_job</code>, <code>resume_job</code>, <code>abort_job</code></li> </ul>"},{"location":"architecture/#channel-modes","title":"Channel Modes","text":"<p>Feature flags expose the same API over different channel backends.</p> <ul> <li><code>bounded-channel</code> (default): <code>tokio::sync::mpsc::channel(size)</code></li> <li><code>unbounded-channel</code>: <code>tokio::sync::mpsc::unbounded_channel()</code></li> </ul>"},{"location":"core-concepts/","title":"Core Concepts","text":""},{"location":"core-concepts/#1-actor","title":"1) Actor","text":"<p>Each actor implements the <code>Actor</code> trait.</p> <ul> <li><code>type Message</code>: message type this actor accepts</li> <li><code>type Result</code>: handler result type</li> <li><code>type Error</code>: handler error type</li> <li><code>handle(&amp;mut self, Arc&lt;Self::Message&gt;)</code></li> </ul> <p>Each actor defines its own independent message type.</p>"},{"location":"core-concepts/#2-actorsystem","title":"2) ActorSystem","text":"<p><code>ActorSystem</code> manages actors by address (<code>String</code>).</p> <ul> <li>register: <code>register(...)</code></li> <li>send: <code>send::&lt;T&gt;(address, msg)</code></li> <li>request/response: <code>send_and_recv::&lt;T&gt;(address, msg)</code></li> <li>broadcast: <code>send_broadcast::&lt;T&gt;(regex, msg)</code></li> <li>job execution: <code>run_job::&lt;T&gt;(...)</code></li> </ul>"},{"location":"core-concepts/#3-type-safety-model","title":"3) Type-Safety Model","text":""},{"location":"core-concepts/#compile-time-guarantees","title":"Compile-Time Guarantees","text":"<p><code>send::&lt;T&gt;()</code> accepts <code>&lt;T as Actor&gt;::Message</code>. Once <code>T</code> is chosen, the message type is fixed at compile time.</p> <p>For example, <code>send::&lt;MyActor1&gt;(..., MyMessage2::B(...))</code> does not compile.</p>"},{"location":"core-concepts/#runtime-guarantees","title":"Runtime Guarantees","text":"<p>Addresses are plain strings, so address-to-actor-type matching is validated at runtime.</p> <ul> <li>system stores <code>actor_type</code> with each address</li> <li><code>FindActor</code> checks type equality</li> <li>mismatch returns runtime errors such as <code>AddressNotFound</code> or <code>MessageTypeMismatch</code></li> </ul> <p>In short:</p> <ul> <li>message type compatibility: compile time</li> <li>address mapping compatibility: runtime</li> </ul>"},{"location":"core-concepts/#4-lifecycle-and-failure-handling","title":"4) Lifecycle and Failure Handling","text":"<p>Actor lifecycle states:</p> <ul> <li><code>Starting</code></li> <li><code>Receiving</code></li> <li><code>Stopping</code></li> <li><code>Terminated</code></li> <li><code>Restarting</code></li> </ul> <p>On handler error, behavior depends on <code>ErrorHandling</code>:</p> <ul> <li><code>Resume</code>: continue actor loop</li> <li><code>Restart</code>: restart actor</li> <li><code>Stop</code>: terminate actor</li> </ul>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#install","title":"Install","text":"<pre><code>cargo add xan-actor\ncargo add async-trait\n</code></pre> <p><code>bounded-channel</code> is the default.</p> <p>To use unbounded mode:</p> <pre><code>cargo add xan-actor --no-default-features --features unbounded-channel\n</code></pre>"},{"location":"quickstart/#minimal-example","title":"Minimal Example","text":"<pre><code>use xan_actor::prelude::*;\nuse std::sync::Arc;\n\n#[derive(Debug, Clone)]\nenum MsgA {\n    Ping(String),\n}\n\n#[derive(Debug, Clone)]\nenum MsgB {\n    Echo(String),\n}\n\n#[derive(thiserror::Error, Debug)]\nenum MyError {\n    #[error(transparent)]\n    Actor(#[from] ActorError),\n}\n\nstruct ActorA {\n    address: String,\n}\n\nstruct ActorB {\n    address: String,\n}\n\n#[async_trait::async_trait]\nimpl Actor for ActorA {\n    type Message = MsgA;\n    type Result = MsgA;\n    type Error = MyError;\n\n    fn address(&amp;self) -&gt; &amp;str { &amp;self.address }\n\n    async fn handle(&amp;mut self, msg: Arc&lt;Self::Message&gt;) -&gt; Result&lt;Self::Result, Self::Error&gt; {\n        Ok((*msg).clone())\n    }\n}\n\n#[async_trait::async_trait]\nimpl Actor for ActorB {\n    type Message = MsgB;\n    type Result = MsgB;\n    type Error = MyError;\n\n    fn address(&amp;self) -&gt; &amp;str { &amp;self.address }\n\n    async fn handle(&amp;mut self, msg: Arc&lt;Self::Message&gt;) -&gt; Result&lt;Self::Result, Self::Error&gt; {\n        Ok((*msg).clone())\n    }\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), ActorError&gt; {\n    let mut system = ActorSystem::new(None);\n\n    ActorA { address: \"/a/1\".into() }\n        .register(&amp;mut system, ErrorHandling::Stop, Blocking::NonBlocking, None)\n        .await?;\n\n    ActorB { address: \"/b/1\".into() }\n        .register(&amp;mut system, ErrorHandling::Stop, Blocking::NonBlocking, None)\n        .await?;\n\n    // compile-time check: only MsgA is accepted here\n    system.send::&lt;ActorA&gt;(\"/a/1\".into(), MsgA::Ping(\"hello\".into())).await?;\n\n    let result = system\n        .send_and_recv::&lt;ActorB&gt;(\"/b/1\".into(), MsgB::Echo(\"world\".into()))\n        .await?;\n    println!(\"result = {:?}\", result);\n\n    Ok(())\n}\n</code></pre>"},{"location":"quickstart/#what-this-shows","title":"What This Shows","text":"<ul> <li>one <code>ActorSystem</code> hosting <code>ActorA</code> and <code>ActorB</code></li> <li><code>send::&lt;ActorA&gt;</code> accepts only <code>MsgA</code></li> <li><code>send_and_recv::&lt;ActorB&gt;</code> returns <code>ActorB::Result</code></li> </ul>"},{"location":"ko/","title":"xan-actor Wiki","text":"<p><code>xan-actor</code>\ub294 Akka \uc2a4\ud0c0\uc77c Actor \ubaa8\ub378\uc744 Rust\ub85c \uad6c\ud604\ud55c \ub77c\uc774\ube0c\ub7ec\ub9ac\uc785\ub2c8\ub2e4.</p> <p>\uc774 \uc704\ud0a4\ub294 \uc544\ub798 \ub0b4\uc6a9\uc744 \uc911\uc2ec\uc73c\ub85c \uc815\ub9ac\ud569\ub2c8\ub2e4.</p> <ul> <li>\ud558\ub098\uc758 <code>ActorSystem</code>\uc5d0\uc11c \uc5ec\ub7ec Actor \ud0c0\uc785\uc744 \ud568\uaed8 \uc6b4\uc6a9\ud558\ub294 \ubc29\uc2dd</li> <li><code>send::&lt;T&gt;()</code> \ud638\ucd9c \uc2dc \ucef4\ud30c\uc77c \ud0c0\uc784\uc5d0 \uba54\uc2dc\uc9c0 \ud0c0\uc785\uc774 \uac80\uc99d\ub418\ub294 \uad6c\uc870</li> <li>\uc8fc\uc18c \uae30\ubc18 \ub77c\uc6b0\ud305\uacfc \ub77c\uc774\ud504\uc0ac\uc774\ud074(\uc7ac\uc2dc\uc791/\uc911\uc9c0/\uc0ad\uc81c) \ucc98\ub9ac</li> <li>bounded/unbounded \ucc44\ub110 \ubaa8\ub4dc \ucc28\uc774</li> </ul>"},{"location":"ko/#_1","title":"\ubb38\uc11c \ub9f5","text":"<ul> <li><code>Core Concepts</code>: \ud575\uc2ec \uac1c\ub150\uacfc \ud0c0\uc785 \uc548\uc815\uc131 \ubaa8\ub378</li> <li><code>Architecture</code>: \ub0b4\ubd80 \ucef4\ud3ec\ub10c\ud2b8 \uad6c\uc870\uc640 \uba54\uc2dc\uc9c0 \ud750\ub984</li> <li><code>Quickstart</code>: \ucd5c\uc18c \uc608\uc81c\ub85c \ub4f1\ub85d/\uc1a1\uc2e0/\uc751\ub2f5 \ubc1b\uae30</li> </ul>"},{"location":"ko/architecture/#_1","title":"\uad6c\uc131 \uc694\uc18c","text":"<ul> <li><code>Actor</code> \uad6c\ud604\uccb4: \uc0ac\uc6a9\uc790 \ube44\uc988\ub2c8\uc2a4 \ub85c\uc9c1</li> <li><code>TypedMailbox&lt;A&gt;</code>: Actor \ud0c0\uc785 <code>A</code>\uc5d0 \ubc14\uc778\ub529\ub41c \uba54\uc77c\ubc15\uc2a4</li> <li><code>ActorSystem</code>: \uc8fc\uc18c/\ud0c0\uc785/\ub77c\uc774\ud504\uc0ac\uc774\ud074 \uad00\ub9ac, \ub77c\uc6b0\ud305, \uc7a1 \uc81c\uc5b4</li> <li><code>actor_system_loop</code>: \uc2dc\uc2a4\ud15c \uba85\ub839 \ucc98\ub9ac \ub8e8\ud504</li> </ul>"},{"location":"ko/architecture/#_2","title":"\uba54\uc2dc\uc9c0 \ud750\ub984","text":"<pre><code>Caller\n  -&gt; ActorSystem::send::&lt;T&gt;(address, msg: T::Message)\n  -&gt; ActorSystemCmd::FindActor { actor_type, address }\n  -&gt; Mailbox.send(payload)\n  -&gt; TypedMailbox&lt;A&gt; downcast to A::Message\n  -&gt; Actor::handle(...)\n</code></pre> <p>\ud575\uc2ec \ud3ec\uc778\ud2b8:</p> <ul> <li>API \ub808\ubca8\uc5d0\uc11c <code>T::Message</code>\ub97c \uc694\uad6c\ud558\ubbc0\ub85c \uc798\ubabb\ub41c \uba54\uc2dc\uc9c0 \ud0c0\uc785\uc740 \ucef4\ud30c\uc77c \uc5d0\ub7ec</li> <li>\ub0b4\ubd80 \uba54\uc77c\ubc15\uc2a4\ub294 <code>Any</code> \uae30\ubc18\uc774\uc9c0\ub9cc, <code>TypedMailbox&lt;A&gt;</code>\uc5d0\uc11c \ub2e4\uc6b4\uce90\uc2a4\ud2b8 \uac80\uc99d</li> </ul>"},{"location":"ko/architecture/#_3","title":"\uc8fc\uc18c\uc640 \ub77c\uc6b0\ud305","text":"<p>\uc8fc\uc18c\ub294 \ubb38\uc790\uc5f4\uc774\uba70 \uc815\uaddc\uc2dd(<code>*</code> \uc640\uc77c\ub4dc\uce74\ub4dc \ubcc0\ud658)\uc73c\ub85c \ud544\ud130\ub9c1\ub429\ub2c8\ub2e4.</p> <ul> <li><code>send_broadcast::&lt;T&gt;(regex, msg)</code>\ub294 \ub9e4\uce6d\ub41c \uc8fc\uc18c \uc804\uccb4\uc5d0 \uc804\uc1a1</li> <li>\uce90\uc2dc(<code>cache</code>)\ub97c \uc0ac\uc6a9\ud574 \ubc18\ubcf5 \uc1a1\uc2e0 \uacbd\ub85c\ub97c \ucd5c\uc801\ud654</li> <li>\uce90\uc2dc \ud0c0\uc785 \ubd88\uc77c\uce58/\uc1a1\uc2e0 \uc2e4\ud328 \uc2dc \uce90\uc2dc \uc81c\uac70 \ud6c4 \uc7ac\uc870\ud68c</li> </ul>"},{"location":"ko/architecture/#job","title":"\uc7a1(Job) \uc2e4\ud589 \ubaa8\ub378","text":"<p><code>run_job::&lt;T&gt;()</code>\ub294 \uc8fc\uae30/\ud69f\uc218/\uc2dc\uc791\uc2dc\uac01\uc744 \ub2f4\uc740 <code>JobSpec</code>\uc744 \ubc1b\uc544 \ube44\ub3d9\uae30 \uc791\uc5c5\uc744 \uc2e4\ud589\ud569\ub2c8\ub2e4.</p> <ul> <li><code>subscribe = true</code>: \uacb0\uacfc \ucc44\ub110(<code>result_subscriber_rx</code>) \uc81c\uacf5</li> <li>\uc81c\uc5b4 \ucc44\ub110: <code>stop_job</code>, <code>resume_job</code>, <code>abort_job</code></li> </ul>"},{"location":"ko/architecture/#_4","title":"\ucc44\ub110 \ubaa8\ub4dc","text":"<p>\uae30\ub2a5 \ud50c\ub798\uadf8\ub85c \ub3d9\uc77c\ud55c \uc778\ud130\ud398\uc774\uc2a4\ub97c \ub450 \ubc29\uc2dd\uc73c\ub85c \uc81c\uacf5\ud569\ub2c8\ub2e4.</p> <ul> <li><code>bounded-channel</code> (\uae30\ubcf8): <code>tokio::sync::mpsc::channel(size)</code></li> <li><code>unbounded-channel</code>: <code>tokio::sync::mpsc::unbounded_channel()</code></li> </ul> <p>API \ud615\ud0dc\ub294 \ub3d9\uc77c\ud558\uace0 \ub0b4\ubd80 \ucc44\ub110 \ud0c0\uc785\ub9cc \ub2ec\ub77c\uc9d1\ub2c8\ub2e4.</p>"},{"location":"ko/core-concepts/#1-actor","title":"1) Actor","text":"<p>\uac01 Actor\ub294 <code>Actor</code> \ud2b8\ub808\uc774\ud2b8\ub97c \uad6c\ud604\ud569\ub2c8\ub2e4.</p> <ul> <li><code>type Message</code>: \ud574\ub2f9 Actor\uac00 \ubc1b\uc744 \uc218 \uc788\ub294 \uba54\uc2dc\uc9c0 \ud0c0\uc785</li> <li><code>type Result</code>: \ud578\ub4e4\ub7ec \uacb0\uacfc \ud0c0\uc785</li> <li><code>type Error</code>: \ud578\ub4e4\ub7ec \uc5d0\ub7ec \ud0c0\uc785</li> <li><code>handle(&amp;mut self, Arc&lt;Self::Message&gt;)</code></li> </ul> <p>\ud575\uc2ec\uc740 Actor\ub9c8\ub2e4 \uba54\uc2dc\uc9c0 \ud0c0\uc785\uc774 \ub3c5\ub9bd\uc801\uc73c\ub85c \uc815\uc758\ub41c\ub2e4\ub294 \uc810\uc785\ub2c8\ub2e4.</p>"},{"location":"ko/core-concepts/#2-actorsystem","title":"2) ActorSystem","text":"<p><code>ActorSystem</code>\uc740 \uc8fc\uc18c(<code>String</code>)\ub97c \uae30\uc900\uc73c\ub85c Actor\ub97c \uad00\ub9ac\ud569\ub2c8\ub2e4.</p> <ul> <li>\ub4f1\ub85d: <code>register(...)</code></li> <li>\ub2e8\uac74 \uc1a1\uc2e0: <code>send::&lt;T&gt;(address, msg)</code></li> <li>\uc694\uccad/\uc751\ub2f5: <code>send_and_recv::&lt;T&gt;(address, msg)</code></li> <li>\ube0c\ub85c\ub4dc\uce90\uc2a4\ud2b8: <code>send_broadcast::&lt;T&gt;(regex, msg)</code></li> <li>\uc7a1 \uc2e4\ud589: <code>run_job::&lt;T&gt;(...)</code></li> </ul>"},{"location":"ko/core-concepts/#3","title":"3) \ud0c0\uc785 \uc548\uc815\uc131 \ubaa8\ub378","text":""},{"location":"ko/core-concepts/#_1","title":"\ucef4\ud30c\uc77c \ud0c0\uc784 \ubcf4\uc7a5","text":"<p><code>send::&lt;T&gt;()</code>\uc758 \uba54\uc2dc\uc9c0 \uc778\uc790\ub294 <code>&lt;T as Actor&gt;::Message</code>\uc785\ub2c8\ub2e4. \uc989 <code>T</code>\ub97c \uc9c0\uc815\ud558\uba74 \uba54\uc2dc\uc9c0 \ud0c0\uc785\uc774 \ucef4\ud30c\uc77c \ud0c0\uc784\uc5d0 \uace0\uc815\ub429\ub2c8\ub2e4.</p> <p>\uc608\ub97c \ub4e4\uc5b4 <code>send::&lt;MyActor1&gt;(..., MyMessage2::B(...))</code>\ub294 \ucef4\ud30c\uc77c\ub418\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.</p>"},{"location":"ko/core-concepts/#_2","title":"\ub7f0\ud0c0\uc784 \ubcf4\uc7a5","text":"<p>\uc8fc\uc18c\ub294 \ubb38\uc790\uc5f4\uc774\ubbc0\ub85c, \uc8fc\uc18c\uac00 \uc2e4\uc81c\ub85c <code>T</code> \ud0c0\uc785 Actor\ub97c \uac00\ub9ac\ud0a4\ub294\uc9c0\ub294 \ub7f0\ud0c0\uc784\uc5d0 \ud655\uc778\ud569\ub2c8\ub2e4.</p> <ul> <li>\ub0b4\ubd80\uc801\uc73c\ub85c <code>actor_type</code>\uc744 \ud568\uaed8 \uc800\uc7a5</li> <li><code>FindActor</code> \uc2dc \ud0c0\uc785 \uc77c\uce58 \ud655\uc778</li> <li>\ubd88\uc77c\uce58 \uc2dc <code>AddressNotFound</code> \ub610\ub294 <code>MessageTypeMismatch</code> \ub4f1\uc73c\ub85c \uc2e4\ud328 \ucc98\ub9ac</li> </ul> <p>\uc815\ub9ac\ud558\uba74:</p> <ul> <li>\uba54\uc2dc\uc9c0 \ud0c0\uc785 \uc801\ud569\uc131: \ucef4\ud30c\uc77c \ud0c0\uc784</li> <li>\uc8fc\uc18c-Actor \ub9e4\ud551 \uc801\ud569\uc131: \ub7f0\ud0c0\uc784</li> </ul>"},{"location":"ko/core-concepts/#4","title":"4) \ub77c\uc774\ud504\uc0ac\uc774\ud074\uacfc \uc7a5\uc560 \ucc98\ub9ac","text":"<p>Actor \ub77c\uc774\ud504\uc0ac\uc774\ud074:</p> <ul> <li><code>Starting</code></li> <li><code>Receiving</code></li> <li><code>Stopping</code></li> <li><code>Terminated</code></li> <li><code>Restarting</code></li> </ul> <p>\ud578\ub4e4\ub7ec \uc5d0\ub7ec \ubc1c\uc0dd \uc2dc \uc815\ucc45(<code>ErrorHandling</code>)\uc5d0 \ub530\ub77c \ub3d9\uc791\uc774 \ub2ec\ub77c\uc9d1\ub2c8\ub2e4.</p> <ul> <li><code>Resume</code>: \ud604\uc7ac Actor \uacc4\uc18d \uc2e4\ud589</li> <li><code>Restart</code>: Actor \uc7ac\uc2dc\uc791</li> <li><code>Stop</code>: Actor \uc885\ub8cc</li> </ul>"},{"location":"ko/quickstart/#_1","title":"\uc124\uce58","text":"<pre><code>cargo add xan-actor\ncargo add async-trait\n</code></pre> <p><code>bounded-channel</code>\uc774 \uae30\ubcf8\uc785\ub2c8\ub2e4.</p> <p>unbounded\ub97c \uc4f0\ub824\uba74:</p> <pre><code>cargo add xan-actor --no-default-features --features unbounded-channel\n</code></pre>"},{"location":"ko/quickstart/#_2","title":"\ucd5c\uc18c \uc608\uc81c","text":"<pre><code>use xan_actor::prelude::*;\nuse std::sync::Arc;\n\n#[derive(Debug, Clone)]\nenum MsgA {\n    Ping(String),\n}\n\n#[derive(Debug, Clone)]\nenum MsgB {\n    Echo(String),\n}\n\n#[derive(thiserror::Error, Debug)]\nenum MyError {\n    #[error(transparent)]\n    Actor(#[from] ActorError),\n}\n\nstruct ActorA {\n    address: String,\n}\n\nstruct ActorB {\n    address: String,\n}\n\n#[async_trait::async_trait]\nimpl Actor for ActorA {\n    type Message = MsgA;\n    type Result = MsgA;\n    type Error = MyError;\n\n    fn address(&amp;self) -&gt; &amp;str { &amp;self.address }\n\n    async fn handle(&amp;mut self, msg: Arc&lt;Self::Message&gt;) -&gt; Result&lt;Self::Result, Self::Error&gt; {\n        Ok((*msg).clone())\n    }\n}\n\n#[async_trait::async_trait]\nimpl Actor for ActorB {\n    type Message = MsgB;\n    type Result = MsgB;\n    type Error = MyError;\n\n    fn address(&amp;self) -&gt; &amp;str { &amp;self.address }\n\n    async fn handle(&amp;mut self, msg: Arc&lt;Self::Message&gt;) -&gt; Result&lt;Self::Result, Self::Error&gt; {\n        Ok((*msg).clone())\n    }\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), ActorError&gt; {\n    let mut system = ActorSystem::new(None);\n\n    ActorA { address: \"/a/1\".into() }\n        .register(&amp;mut system, ErrorHandling::Stop, Blocking::NonBlocking, None)\n        .await?;\n\n    ActorB { address: \"/b/1\".into() }\n        .register(&amp;mut system, ErrorHandling::Stop, Blocking::NonBlocking, None)\n        .await?;\n\n    // \ucef4\ud30c\uc77c \ud0c0\uc784 \uac80\uc99d: MsgA\ub9cc \ubcf4\ub0bc \uc218 \uc788\uc74c\n    system.send::&lt;ActorA&gt;(\"/a/1\".into(), MsgA::Ping(\"hello\".into())).await?;\n\n    let result = system\n        .send_and_recv::&lt;ActorB&gt;(\"/b/1\".into(), MsgB::Echo(\"world\".into()))\n        .await?;\n    println!(\"result = {:?}\", result);\n\n    Ok(())\n}\n</code></pre>"},{"location":"ko/quickstart/#_3","title":"\uc2e4\ud589 \ud3ec\uc778\ud2b8","text":"<ul> <li>\ud558\ub098\uc758 <code>ActorSystem</code>\uc5d0 <code>ActorA</code>, <code>ActorB</code>\ub97c \ud568\uaed8 \ub4f1\ub85d</li> <li><code>send::&lt;ActorA&gt;</code>\ub294 <code>MsgA</code>\ub9cc \ud5c8\uc6a9</li> <li><code>send_and_recv::&lt;ActorB&gt;</code>\ub294 \uacb0\uacfc \ud0c0\uc785\ub3c4 <code>ActorB::Result</code>\ub85c \uace0\uc815</li> </ul>"},{"location":"","title":"xan-actor Wiki","text":"<p><code>xan-actor</code> is an Akka-style Actor model library implemented in Rust.</p> <p>This wiki focuses on:</p> <ul> <li>running multiple Actor types in a single <code>ActorSystem</code></li> <li>compile-time message type checking via <code>send::&lt;T&gt;()</code></li> <li>address-based routing and lifecycle control</li> <li>bounded/unbounded channel modes</li> </ul>"},{"location":"#documentation-map","title":"Documentation Map","text":"<ul> <li><code>Core Concepts</code>: core concepts and type-safety model</li> <li><code>Architecture</code>: internal components and message flow</li> <li><code>Quickstart</code>: minimal example for register/send/recv</li> </ul>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#components","title":"Components","text":"<ul> <li><code>Actor</code> implementations: user business logic</li> <li><code>TypedMailbox&lt;A&gt;</code>: mailbox bound to actor type <code>A</code></li> <li><code>ActorSystem</code>: routing, lifecycle, cache, and job control</li> <li><code>actor_system_loop</code>: command-processing loop</li> </ul>"},{"location":"architecture/#message-flow","title":"Message Flow","text":"<pre><code>Caller\n  -&gt; ActorSystem::send::&lt;T&gt;(address, msg: T::Message)\n  -&gt; ActorSystemCmd::FindActor { actor_type, address }\n  -&gt; Mailbox.send(payload)\n  -&gt; TypedMailbox&lt;A&gt; downcast to A::Message\n  -&gt; Actor::handle(...)\n</code></pre> <p>Key points:</p> <ul> <li>API requires <code>T::Message</code>, so wrong message types fail at compile time</li> <li>internals use <code>Any</code>, but <code>TypedMailbox&lt;A&gt;</code> validates via downcast</li> </ul>"},{"location":"architecture/#address-and-routing","title":"Address and Routing","text":"<p>Addresses are strings filtered by regex (<code>*</code> wildcard conversion).</p> <ul> <li><code>send_broadcast::&lt;T&gt;(regex, msg)</code> sends to every matched address</li> <li>cache (<code>cache</code>) optimizes repeated sends</li> <li>cache entry is dropped when type mismatch or send failure occurs</li> </ul>"},{"location":"architecture/#job-execution-model","title":"Job Execution Model","text":"<p><code>run_job::&lt;T&gt;()</code> executes periodic/iterative messages from <code>JobSpec</code>.</p> <ul> <li><code>subscribe = true</code>: returns <code>result_subscriber_rx</code></li> <li>control APIs: <code>stop_job</code>, <code>resume_job</code>, <code>abort_job</code></li> </ul>"},{"location":"architecture/#channel-modes","title":"Channel Modes","text":"<p>Feature flags expose the same API over different channel backends.</p> <ul> <li><code>bounded-channel</code> (default): <code>tokio::sync::mpsc::channel(size)</code></li> <li><code>unbounded-channel</code>: <code>tokio::sync::mpsc::unbounded_channel()</code></li> </ul>"},{"location":"core-concepts/","title":"Core Concepts","text":""},{"location":"core-concepts/#1-actor","title":"1) Actor","text":"<p>Each actor implements the <code>Actor</code> trait.</p> <ul> <li><code>type Message</code>: message type this actor accepts</li> <li><code>type Result</code>: handler result type</li> <li><code>type Error</code>: handler error type</li> <li><code>handle(&amp;mut self, Arc&lt;Self::Message&gt;)</code></li> </ul> <p>Each actor defines its own independent message type.</p>"},{"location":"core-concepts/#2-actorsystem","title":"2) ActorSystem","text":"<p><code>ActorSystem</code> manages actors by address (<code>String</code>).</p> <ul> <li>register: <code>register(...)</code></li> <li>send: <code>send::&lt;T&gt;(address, msg)</code></li> <li>request/response: <code>send_and_recv::&lt;T&gt;(address, msg)</code></li> <li>broadcast: <code>send_broadcast::&lt;T&gt;(regex, msg)</code></li> <li>job execution: <code>run_job::&lt;T&gt;(...)</code></li> </ul>"},{"location":"core-concepts/#3-type-safety-model","title":"3) Type-Safety Model","text":""},{"location":"core-concepts/#compile-time-guarantees","title":"Compile-Time Guarantees","text":"<p><code>send::&lt;T&gt;()</code> accepts <code>&lt;T as Actor&gt;::Message</code>. Once <code>T</code> is chosen, the message type is fixed at compile time.</p> <p>For example, <code>send::&lt;MyActor1&gt;(..., MyMessage2::B(...))</code> does not compile.</p>"},{"location":"core-concepts/#runtime-guarantees","title":"Runtime Guarantees","text":"<p>Addresses are plain strings, so address-to-actor-type matching is validated at runtime.</p> <ul> <li>system stores <code>actor_type</code> with each address</li> <li><code>FindActor</code> checks type equality</li> <li>mismatch returns runtime errors such as <code>AddressNotFound</code> or <code>MessageTypeMismatch</code></li> </ul> <p>In short:</p> <ul> <li>message type compatibility: compile time</li> <li>address mapping compatibility: runtime</li> </ul>"},{"location":"core-concepts/#4-lifecycle-and-failure-handling","title":"4) Lifecycle and Failure Handling","text":"<p>Actor lifecycle states:</p> <ul> <li><code>Starting</code></li> <li><code>Receiving</code></li> <li><code>Stopping</code></li> <li><code>Terminated</code></li> <li><code>Restarting</code></li> </ul> <p>On handler error, behavior depends on <code>ErrorHandling</code>:</p> <ul> <li><code>Resume</code>: continue actor loop</li> <li><code>Restart</code>: restart actor</li> <li><code>Stop</code>: terminate actor</li> </ul>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#install","title":"Install","text":"<pre><code>cargo add xan-actor\ncargo add async-trait\n</code></pre> <p><code>bounded-channel</code> is the default.</p> <p>To use unbounded mode:</p> <pre><code>cargo add xan-actor --no-default-features --features unbounded-channel\n</code></pre>"},{"location":"quickstart/#minimal-example","title":"Minimal Example","text":"<pre><code>use xan_actor::prelude::*;\nuse std::sync::Arc;\n\n#[derive(Debug, Clone)]\nenum MsgA {\n    Ping(String),\n}\n\n#[derive(Debug, Clone)]\nenum MsgB {\n    Echo(String),\n}\n\n#[derive(thiserror::Error, Debug)]\nenum MyError {\n    #[error(transparent)]\n    Actor(#[from] ActorError),\n}\n\nstruct ActorA {\n    address: String,\n}\n\nstruct ActorB {\n    address: String,\n}\n\n#[async_trait::async_trait]\nimpl Actor for ActorA {\n    type Message = MsgA;\n    type Result = MsgA;\n    type Error = MyError;\n\n    fn address(&amp;self) -&gt; &amp;str { &amp;self.address }\n\n    async fn handle(&amp;mut self, msg: Arc&lt;Self::Message&gt;) -&gt; Result&lt;Self::Result, Self::Error&gt; {\n        Ok((*msg).clone())\n    }\n}\n\n#[async_trait::async_trait]\nimpl Actor for ActorB {\n    type Message = MsgB;\n    type Result = MsgB;\n    type Error = MyError;\n\n    fn address(&amp;self) -&gt; &amp;str { &amp;self.address }\n\n    async fn handle(&amp;mut self, msg: Arc&lt;Self::Message&gt;) -&gt; Result&lt;Self::Result, Self::Error&gt; {\n        Ok((*msg).clone())\n    }\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), ActorError&gt; {\n    let mut system = ActorSystem::new(None);\n\n    ActorA { address: \"/a/1\".into() }\n        .register(&amp;mut system, ErrorHandling::Stop, Blocking::NonBlocking, None)\n        .await?;\n\n    ActorB { address: \"/b/1\".into() }\n        .register(&amp;mut system, ErrorHandling::Stop, Blocking::NonBlocking, None)\n        .await?;\n\n    // compile-time check: only MsgA is accepted here\n    system.send::&lt;ActorA&gt;(\"/a/1\".into(), MsgA::Ping(\"hello\".into())).await?;\n\n    let result = system\n        .send_and_recv::&lt;ActorB&gt;(\"/b/1\".into(), MsgB::Echo(\"world\".into()))\n        .await?;\n    println!(\"result = {:?}\", result);\n\n    Ok(())\n}\n</code></pre>"},{"location":"quickstart/#what-this-shows","title":"What This Shows","text":"<ul> <li>one <code>ActorSystem</code> hosting <code>ActorA</code> and <code>ActorB</code></li> <li><code>send::&lt;ActorA&gt;</code> accepts only <code>MsgA</code></li> <li><code>send_and_recv::&lt;ActorB&gt;</code> returns <code>ActorB::Result</code></li> </ul>"}]}